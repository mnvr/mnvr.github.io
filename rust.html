<!DOCTYPE html>
<html lang="en">

<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width">

<title>A Rust shaped hole | mnvr.in</title>
<meta name="description" content="Without writing a single line of Rust, why I feel it might be right">

<style>
:root {
  color-scheme: light dark;
}
p {
  max-width: 72ch;
}
</style>

</head>

<body>

<p>
By a process of elimination, I've arrived at a conclusion that I should write Rust, or at least give
it a rigorous try. This might be a wrong conclusion, but the following is the reasoning.
</p>

Let us say I want to write a "native" program.

> This chain of thought started with thinking about writing a program that serves as my desktop background, slowly meandering though a pastel game of life, or floating through a Mandelbrot set. An xfdestkop replacement, as one would call it. But the specifics are not relevant, because then soon enough I started thinking in more general terms, say if I want to write an arbitrary "native" CLI program, etc.

My weapon of choice is TypeScript, and it is a sword light to wield, cutting through problems like butter. TypeScript also compiles to JavaScript, so it runs everywhere. Or does it?

While I can jump through hoops to compile JavaScript into a binary, this doesn't "feel" "solid". The point of writing a native program in the first place is to make it feel solid.

> Maybe this is preconception on my part, maybe one day the TypeScript -> JavaScript -> WASM -> binary pipeline will be straightforward, or maybe it already is and I just am not aware.

<p>
That leaves me with the following options (in an arbitrary order) — C, C++, go, Rust.
</p>

Technically, there are a lot more options, and I wrote a long section here about eliminating them piecewise, but after writing it I felt it was just noise — the reason why anything apart from these four is apparent to any discerning viewer, and I don't need to rant about it.

Of these, C++ is the easiest to eliminate. I once spent an entire year in the heaven of C++, walking around in daze of std::vector and RAII, before one day snapping out of it and realizing that I was just spawning complexity that is unrelated to the problem at hand. The experience was so vivid that I've never felt the urge to partake in C++ ever again.

So C, go and Rust. Let's begin.

---

There are two dimensions at play here - "Simplicity" and memory management.

I put simplicity in quotes because there is a lot more I need to say on that word.

C is a simple language. This is fact I agree with and appreciate. It is the reason for it's endurance in the open source world. If someone posts a patch or submits a PR to a codebase written in idiomatic C, it is easier to review than any other mainstream language. There is no magic (the possibility is there, but not in "idiomatic" C which has come up with conventions to thwart such spooky macro action at a distance).

This allows the code to evolve line by line, guided by many casual hands that might not be seeped in its lore, who're just making a drive by bug fix or enhancement. Changes are local. Of course, it is possible to make global changes by redefining the behaviour of a often used function, but such a change cannot happen accidentally, and is easy to spot when reviewing. Patches are just that — evolutions of lines.

In contrast, Haskell is not a simple language. The non-simplicity is at play both in the language itself, as evidenced by its intimidating syntax, but also in the source code artifacts written in it — changes are not localized, the entire Haskell program is one whole; a giant equation that will spit out the answer you want. This is in contrast to the step by step plodding along that the C program would be asked to do to get there.

There is an apocryphal story about Euler in elementary school solving all the math problems that the teacher gave to the class in a jiffy, so the teacher tells him to sum up the numbers to a thousand to get him to stop pestering for more. The expectation was that Euler would go through the numbers "imperatively" like C, summing them up. Instead, what Euler did was rediscover the summation formula and solved it "declaratively" like Haskell, in one go, as an equation.

This also shows the tradeoff between simplicity and abstraction. At a high level of abstraction, things solve themselves as if by magic. But not everyone is Euler, and a crowd of occasional drive-by contributors even less so when taken as a collective whole.

A tradeoff by definition means there is no one right or wrong answer. "It depends".

Personally, I've found TypeScript to be the golden glove. Not too low, not too high, a cosy promontory on the mountain of abstraction. And after having lived here for a while, it feels that I'd not like the view from any lower.

Hold that thought though, let's look at the other dimension first. Memory management.

Computers operate in the nanosecond ranges which are alien for our timescales. To parphrase Norvig's <cite>Latency numbers a programmer should know</cite>, if we imagine a computer that executes 1 CPU instruction every second, it would take it <b>days</b> to read from RAM.

There is plenty of room at the bottom, as Feynman said. C is not fast because it runs "native instructions" (seconds), it is fast because an expert C programmer can eliminate day equivalents from the program's runtime by optimizing memory access.


</body>
</html>
