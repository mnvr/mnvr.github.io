<!DOCTYPE html>
<html lang="en">

<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width">

<title>A Rust shaped hole | mnvr.in</title>
<meta name="description" content="Without writing a single line of Rust, why I feel it might be right">

<style>
:root {
  color-scheme: light dark;
}
p {
  max-width: 72ch;
}
</style>

</head>

<body>

<p>
By a process of elimination, I've arrived at a conclusion that I should write Rust, or at least give
it a rigorous try. This might be a wrong conclusion, but the following is the reasoning.
</p>

Let us say I want to write a "native" program.

> This chain of thought started with thinking about writing a program that serves as my desktop background, slowly meandering though a pastel game of life, or floating through a Mandelbrot set. An xfdestkop replacement, as one would call it. But the specifics are not relevant, because then soon enough I started thinking in more general terms, say if I want to write an arbitrary "native" CLI program, etc.

My weapon of choice is TypeScript, and it is a sword light to wield, cutting through problems like butter. TypeScript also compiles to JavaScript, so it runs everywhere. Or does it?

While I can jump through hoops to compile JavaScript into a binary, this doesn't "feel" "solid". The point of writing a native program in the first place is to make it feel solid.

> Maybe this is preconception on my part, maybe one day the TypeScript -> JavaScript -> WASM -> binary pipeline will be straightforward, or maybe it already is and I just am not aware.

<p>
That leaves me with the following options (in an arbitrary order) — C, C++, go, Rust.
</p>

Technically, there are a lot more options, and I wrote a long section here about eliminating them piecewise, but after writing it I felt it was just noise — the reason why anything apart from these four is apparent to any discerning viewer, and I don't need to rant about it.

Of these, C++ is the easiest to eliminate. I once spent an entire year in the heaven of C++, walking around in daze of std::vector and RAII, before one day snapping out of it and realizing that I was just spawning complexity that is unrelated to the problem at hand. The experience was so vivid that I've never felt the urge to partake in C++ ever again.

So C, go and Rust. Let's begin.

---

There are two dimensions at play here - "Simplicity" and memory management.

I put simplicity in quotes because there is a lot more I need to say on that word.

C is a simple language. This is fact I agree with and appreciate. It is the reason for it's endurance in the open source world. If someone posts a patch or submits a PR to a codebase written in idiomatic C, it is easier to review than any other mainstream language. There is no magic (the possibility is there, but not in "idiomatic" C which has come up with conventions to thwart such spooky macro action at a distance).

This allows the code to evolve line by line, guided by many casual hands that might not be seeped in its lore, who're just making a drive by bug fix or enhancement. Changes are local. Of course, it is possible to make global changes by redefining the behaviour of a often used function, but such a change cannot happen accidentally, and is easy to spot when reviewing. Patches are just that — evolutions of lines.

In contrast, Haskell is not a simple language. The non-simplicity is at play both in the language itself, as evidenced by its intimidating syntax, but also in the source code artifacts written in it — changes are not localized, the entire Haskell program is one whole; a giant equation that will spit out the answer you want. This is in contrast to the step by step plodding along that the C program would be asked to do to get there.

There is an apocryphal story about Euler(?) in elementary school solving all the math problems that the teacher gave to the class in a jiffy, so the teacher tells him to sum up the numbers to a thousand to get him to stop pestering for more. The expectation was that Euler would go through the numbers "imperatively" like C, summing them up. Instead, what Euler did was rediscover the summation formula and solved it "declaratively" like Haskell, in one go, as an equation.

This also shows the tradeoff between simplicity and abstraction. At a high level of abstraction, things solve themselves as if by magic. But not everyone is Euler, and a crowd of occasional drive-by contributors even less so when taken as a collective whole.

A tradeoff by definition means there is no one right or wrong answer. "It depends".

Personally, I've found TypeScript to be the golden glove. Not too low, not too high, a cosy promontory on the mountain of abstraction. And after having lived here for a while, it feels that I'd not like the view from any lower.

Hold that thought though, let's look at the other dimension first. Memory management.

Computers operate in the nanosecond ranges which are alien for our timescales. To parphrase Norvig's <cite>Latency numbers a programmer should know</cite>, if we imagine a computer that executes 1 CPU instruction every second, it would take it <b>days</b> to read from RAM.

There is plenty of room at the bottom, as Feynman said. C is not fast because it runs "native instructions" (seconds), it is fast because an expert C programmer can eliminate day-equivalents from the program's runtime by optimizing memory access.

In light of all this, it is enticing to build a narrative that goes like this:

* When go "modernized" C, it added all sorts of conveniences, but one that went too far was memory management.

* So when Rust "modernized" C, it kept the other conveniences, but wrested back control of memory management to be "fast".

But this is false in more ways than one. Let's talk of the one truth there though - Go indeed is an attempt at a C v2.

Go retains the same "line level" simplicity of C. The impact of changes are local only, sometimes tediously so, but the result is a code base that behaves predictably, and evolves predictably.

The primary falsehood in that narrative is the presumption that one necessarily needs memory management to be fast. This is also the reason that I'd thought that Rust was a problem looking for a solution. Let me illustrate.

The claim I'm making is that languages with automated memory management can be as fast as ones with manually managed memory. This is not easy, but in can be done, and both Go and Haskell are living proof.

There are two aspects of speed — practical, and absolute.

Practically speaking, go is fast enough. We at Ente run go on our servers, and it is ridiculous how little CPU and memory the CPU uses. Optimizing, say, SQL queries, or S3 object placement, even by a small delta will offset even order of magnitude speed improvements in the Go code.

To take a larger example, esbuild sent shockwaves in the the JavaScript ecosystem half a decade ago by demonstrating that current tooling could be made orders of magnitude faster by writing it in Go. It is went made the ecosystem go into the "rewrite everything in go" (and later "rewrite everything in Rust") frenzy. The story has not played out yet - TypeScript itself is being rewritten in Go!

At this point, you might still muse, well, it wouldn't hurt to go faster, right? The absolute speed, so to say.

Haskell here proves that even in absolute terms, a smart compiler is all you need. GHC is the closest thing I've seen to magic in the programming language tooling. I did an Advent of Code once, and I'd write a solution in what seemed like a very very high level of abstraction, closer to Category Theory than to Von Neumann machines. GHC would take that code, transform it into a single static binary that would run as fast as the Rust times that people posted about!

Yes, there will be exceptions. An expert with control of memory management can, using C or Rust, for a particular specific problem, make things happen faster than other languages. But this is not a good use of the expert's time, since we have programming languages that can produce equivalent speed to within an order of magnitude in the general sense.

Or to put it differently, Rust and C make sense in specific domains (e.g. if I was writing the database itself, or the OS), but as an "application layer" programmer, dealing with memory is not a good use of my mental energy.

---

Lots of words. So what do we have:

1. C and Go are simple, but a bit too low on the abstraction ladder for my taste.
2. TypeScript is perfect, but it doesn't produce "native" code.
3. Rust, from what I've heard, has a similar higher level as TypeScript, perhaps even closer to Haskell but that's good, I could do with a bit more help from the compiler. But it requires me to manage memory and lifetimes, which I think is something the compiler should do for me.

One of the three has to give.

There is a wide gaping hole, and I can't think of a better alternative than Rust to fill it, so I am going to give it a try.

---

I've never written a line of Rust in my life. I have decent experience in all the other languages I talked of, so my beliefs, while possibly wrong, are founded in some sense of empiricism. With Rust, it has all been heresay, and I'm a bit excited to see what the reality will look like.


</body>
</html>
