<!DOCTYPE html>
<html lang="en">

<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width">

<title>fm | mnvr.in</title>
<meta name="description" content="">

<style>
:root {
  color-scheme: light dark;
}
body {
  margin-inline: 0;
  margin-block: 1em;
}
.row {
  margin-inline: 1em;
  display: flex;
  gap: 1em;
}
div#seq {
  display: flex;
  margin-block: 0.5em;
  gap: 0.4em;
  div {
    width: 0.5em;
    aspect-ratio: 0.4;
    border: 1px solid color-mix(in srgb, currentColor 50%, transparent);
  }
  div.on {
    background-color: color-mix(in srgb, currentColor 70%, transparent);
  }
}
.row .times {
  display: flex;
  flex-direction: column;
  output {
    min-width: 3em;
    text-align: right;
  }
}
output.fixed {
  font-size: small;
  opacity: 0.7;
}
.scopes {
  display: flex;
  flex-direction: column;
}
.scopes .outputs {
  margin-inline: 1em;
}
</style>

<script type="module">
let audioContext;
let isOn;

const onOff = (e) => {
  const btn = e.target;

  if (!audioContext) {
    audioContext = new AudioContext();
    createAudioGraph();
  }

  isOn = !isOn;
  btn.innerText = isOn ? "Off" : "On";

  if (isOn) {
    audioContext.resume();
    startSequencer();
  } else {
    audioContext.suspend();
  }
}

const dpr = Math.max(Math.floor(devicePixelRatio), 2)

const prepScope = (canvas) => {
  // Assuming 60fps RAF, 44.1 kHZ SR
  // Each frame delta 16ms
  // Each sample (1 / 44100) * 1000 ms
  // Number of samples = 16 / ((1 / 44100) * 1000) = 705.6
  // If dpr is 2, we need 353 samples to cover each RAF.
  const [w, h] = [353, 100];
  canvas.width = w * dpr;
  canvas.height = h * dpr;
  canvas.style.width = `${w}px`;
  canvas.style.height = `${h}px`;

  const ctx = canvas.getContext("2d");
  ctx.lineWidth = dpr;

  return [canvas, ctx];
}

const [canvas1, c1] = prepScope(document.querySelector("canvas#c1"));
const [canvas2, c2] = prepScope(document.querySelector("canvas#c2"));

// c1.strokeColor = "currentColor" doesn't work currently. a workaround.
const dm = matchMedia("(prefers-color-scheme: dark)");
const updateCanvasColors = () => {
  const c = dm.matches ? "#aaa" : "#555";
  c1.strokeStyle = c;
  c2.strokeStyle = c;
}
dm.onchange = updateCanvasColors;
updateCanvasColors();

const samples1 = new Float32Array(canvas1.width);

let osc1;
let amp1;
let analyser1;

const createAudioGraph = () => {
  osc1 = new OscillatorNode(audioContext);
  amp1 = new GainNode(audioContext, { gain: 0 });
  osc1.connect(amp1)
  osc1.start();

  analyser1 = new AnalyserNode(audioContext, {
    // Needs to be a power of 2
    // fftSize: 512 * dpr
    fftSize: 1024 * dpr
  });
  amp1.connect(analyser1);

  const mix = new GainNode(audioContext, { gain: 0.1 });
  amp1.connect(mix);

  mix.connect(audioContext.destination);
}

const timeOutput = document.querySelector("output#time");
const tickOutput = document.querySelector("output#tick");
const bpm = 140;
const bps = bpm / 60;
const tickTime = 1 / bps;
let tick = -1;

const scopeInfoOutput = document.querySelector("output#scopeInfo");
const rafDeltaOutput = document.querySelector("output#rafDelta");


const seq = []
let haveC2ed = false;

const startSequencer = () => {
  // sr - samples per second - reciprocal - second per sample
  const sampleTime = 1 / audioContext.sampleRate;
  document.querySelector("output#sampleTime").innerText =
    `${(sampleTime * 1e3).toFixed(3)} ms`;
  document.querySelector("output#tickTime").innerText =
    `${(tickTime * 1e3).toFixed(3)} ms`;

  const scope1Time = sampleTime * samples1.length;
  scopeInfoOutput.innerText = `${samples1.length} samp ${(scope1Time * 1e3).toFixed(0)} ms`;

  const sl = seq.length;

  let lastT = 0;
  const loop = (dt) => {
    if (!isOn) return;

    const t = audioContext.currentTime;

    timeOutput.innerText = t.toFixed(1);
    requestAnimationFrame(loop);

    rafDeltaOutput.innerText = `${((t - lastT) * 1e3).toFixed(0)} ms RAF`
    lastT = t;

    analyser1.getFloatTimeDomainData(samples1);
    const cy = (x) => rescale(x, [-1, 1], [canvas1.height, 0]);
    c1.clearRect(0, 0, canvas1.width, canvas1.height);
    c1.beginPath();
    c1.moveTo(0, cy(samples1[0]));
    for (let i = 1; i < samples1.length; i++) {
      c1.lineTo(i, cy(samples1[i]));
    }
    c1.stroke();

    if (!haveC2ed && tick == 1) {
      haveC2ed = true;
      c2.beginPath();
      c2.moveTo(0, cy(samples1[0]));
      for (let i = 1; i < samples1.length; i++) {
        c2.lineTo(i, cy(samples1[i]));
      }
      c2.stroke();
    }

    const thisTick = Math.floor(t / tickTime);
    if (thisTick == tick) return;
    tick = thisTick;

    tickOutput.innerText = tick + 1;

    seq[(sl + tick - 1) % sl].classList.remove("on");

    const si = tick % sl;
    seq[si % sl].classList.add("on");

    amp1.gain.setTargetAtTime(1, t, 0.001);
    amp1.gain.setTargetAtTime(0, t + 0.001, tickTime / 5);
    amp1.gain.setValueAtTime(0, t + tickTime / 2);
    // amp1.gain.setTargetAtTime(0, t + 0.05, 0.5)

  };

  requestAnimationFrame(loop);
}

const rescale = (x, [a, b], [c, d]) => ((x - a) / (b - a)) * (d - c) + c;

document.querySelector("button").addEventListener("click", onOff);
const seqD = document.querySelector("#seq");
for (let i = 0; i < 16; i++) {
  const div = document.createElement("div");
  div.setAttribute("data-i", i);
  seqD.appendChild(div);
  seq.push(div);
}
</script>

</head>

<body>

<div class="row">
<button>On</button>
<output id="time"></output>
<output id="tick"></output>
</div>

<div class="row">
<div id="seq"></div>
<div class="times">
<output id="sampleTime" class="fixed"></output>
<output id="tickTime" class="fixed"></output>
</div>
</div>

&nbsp;
<output id="scopeInfo" class="fixed"></output>
<output id="rafDelta" class="fixed"></output>
<br>
<canvas id="c1"></canvas><br>
<canvas id="c2"></canvas><br>
<canvas id="c3"></canvas><br>
<canvas id="c4"></canvas><br>
<canvas id="c5"></canvas><br>
<canvas id="c6"></canvas>

</body>
</html>
