<!DOCTYPE html>
<html lang="en">

<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width">

<title>Linear transforms | mnvr.in</title>
<meta name="description" content="An interactive visualization of linear transforms">

<style>
:root {
  color-scheme: light dark;
}

body {
  margin: 0;
}

.container {
  position: relative;
  width: 100%;
  height: 100vh;
}

canvas, svg {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}

svg circle {
  cursor: grab;
}

svg circle:active {
  cursor: grabbing;
}

#matrix-display {
  position: absolute;
  top: 20px;
  right: 20px;
  display: flex;
  align-items: center;
  font-family: monospace;
  font-size: 18px;
  background: light-dark(rgba(255, 255, 255, 0.9), rgba(0, 0, 0, 0.3));
  padding: 12px;
  border-radius: 4px;
}

.matrix-bracket {
  font-size: 48px;
  line-height: 1;
  font-family: system-ui;
  font-weight: 100;
}

.matrix-values {
  display: flex;
  flex-direction: column;
  gap: 4px;
  margin: 0 6px;
}

.matrix-row {
  display: flex;
  gap: 16px;
}

.matrix-row span {
  width: 50px;
  text-align: right;
}

#m-a, #m-b { color: #e74c3c; }
#m-c, #m-d { color: #3498db; }
</style>

<script type="module">
const canvas = document.querySelector("canvas");
const ctx = canvas.getContext("2d");

const spacing = 50;
const margin = -10;

let width, height;
let halfWidthM, halfHeightM;

function setup() {
  // All drawing will happen in CSS pixels, but we'll scale the canvas pixels
  // to account for the DPR.
  const dpr = Math.floor(Math.min(devicePixelRatio, 2));
  width = canvas.clientWidth;
  height = canvas.clientHeight;

  canvas.width = width * dpr;
  canvas.height = height * dpr;

  halfWidthM = width / 2 - margin;
  halfHeightM = height / 2 - margin;
}

function draw() {
  const dpr = Math.floor(Math.min(devicePixelRatio, 2));
  ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.scale(dpr, dpr);
  ctx.translate(width / 2, height / 2);

  drawGrid();
  drawTransformedGrid();
  drawAxes();
  drawBasisVectors();
  updateHandles();
  updateMatrixDisplay();
}

function drawGrid() {
  ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
  ctx.lineWidth = 1;

  // Vertical lines from center outward
  for (let x = 0; x <= halfWidthM; x += spacing) {
    ctx.beginPath();
    ctx.moveTo(x, -halfHeightM);
    ctx.lineTo(x, halfHeightM);
    ctx.stroke();

    if (x != 0) {
      ctx.beginPath();
      ctx.moveTo(-x, -halfHeightM);
      ctx.lineTo(-x, halfHeightM);
      ctx.stroke();
    }
  }

  for (let y = 0; y <= halfHeightM; y += spacing) {
    ctx.beginPath();
    ctx.moveTo(-halfWidthM, y);
    ctx.lineTo(halfWidthM, y);
    ctx.stroke();

    if (y != 0) {
      ctx.beginPath();
      ctx.moveTo(-halfWidthM, -y);
      ctx.lineTo(halfWidthM, -y);
      ctx.stroke();
    }
  }
}

function drawAxes() {
  ctx.lineWidth = 2;

  ctx.strokeStyle = '#e74c3c';
  ctx.beginPath();
  ctx.moveTo(-halfWidthM, 0);
  ctx.lineTo(halfWidthM, 0);
  ctx.stroke();

  ctx.strokeStyle = '#3498db';
  ctx.beginPath();
  ctx.moveTo(0, -halfHeightM);
  ctx.lineTo(0, halfHeightM);
  ctx.stroke();
}

const unit = spacing; // 1 unit = 50px (same as grid spacing)

const iVec = { x: 1, y: 0 };
const jVec = { x: 0, y: -1 }; // Negative because canvas y is flipped

function drawArrow(from, to, color) {
  const headLength = 10;
  const dx = to.x - from.x;
  const dy = to.y - from.y;
  const angle = Math.atan2(dy, dx);

  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  ctx.strokeStyle = color;
  ctx.fillStyle = color;
  ctx.lineWidth = 3;

  // Line
  ctx.beginPath();
  ctx.moveTo(from.x, from.y);
  ctx.lineTo(to.x, to.y);
  ctx.stroke();

  // Arrowhead
  ctx.beginPath();
  ctx.moveTo(to.x, to.y);
  ctx.lineTo(to.x - headLength * Math.cos(angle - Math.PI / 6), to.y - headLength * Math.sin(angle - Math.PI / 6));
  ctx.lineTo(to.x - headLength * Math.cos(angle + Math.PI / 6), to.y - headLength * Math.sin(angle + Math.PI / 6));
  ctx.closePath();
  ctx.fill();
  ctx.stroke();
}

function drawBasisVectors() {
  const origin = { x: 0, y: 0 };

  const iTip = { x: iVec.x * unit, y: iVec.y * unit };
  const jTip = { x: jVec.x * unit, y: jVec.y * unit };

  drawArrow(origin, iTip, '#e74c3c');
  drawArrow(origin, jTip, '#3498db');
}

const handleRadius = 8;
const handleOffset = handleRadius + 4;

const handleI = document.getElementById('handle-i');
const handleJ = document.getElementById('handle-j');
const handleSum = document.getElementById('handle-sum');

function getHandlePos(v, offset=handleOffset) {
  const angle = Math.atan2(v.y, v.x);
  const x = v.x * unit + offset * Math.cos(angle);
  const y = v.y * unit + offset * Math.sin(angle);
  return { x, y };
}

function updateHandles() {
  const iPos = getHandlePos(iVec);
  const jPos = getHandlePos(jVec);

  const sumVec = { x: iVec.x + jVec.x, y: iVec.y + jVec.y };
  const sumPos = getHandlePos(sumVec, 0);

  handleI.setAttribute('cx', width / 2 + iPos.x);
  handleI.setAttribute('cy', height / 2 + iPos.y);

  handleJ.setAttribute('cx', width / 2 + jPos.x);
  handleJ.setAttribute('cy', height / 2 + jPos.y);

  handleSum.setAttribute('transform',
    `translate(${width / 2 + sumPos.x}, ${height / 2 + sumPos.y})`);
}

function resize() {
  setup();
  draw();
}

let resizeScheduled = false;

window.addEventListener("resize", () => {
  if (resizeScheduled) return;
  resizeScheduled = true;

  requestAnimationFrame(() => {
    resize();
    resizeScheduled = false;
  });
});

function setupHandle(handle, vec) {
  handle.addEventListener('pointerdown', (e) => {
    handle.setPointerCapture(e.pointerId);
  });

  handle.addEventListener('pointermove', (e) => {
    if (!handle.hasPointerCapture(e.pointerId)) return;

    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) - width / 2;
    const y = (e.clientY - rect.top) - height / 2;

    vec.x = x / unit;
    vec.y = y / unit;

    draw();
  });

  handle.addEventListener('pointerup', (e) => {
    handle.releasePointerCapture(e.pointerId);
  });
}

function vecLength(v) {
  return Math.sqrt(v.x * v.x + v.y * v.y);
}

function setupSumHandle(handle) {
  handle.addEventListener('pointerdown', (e) => {
    handle.setPointerCapture(e.pointerId);
  });

  handle.addEventListener('pointermove', (e) => {
    if (!handle.hasPointerCapture(e.pointerId)) return;

    const rect = canvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) - width / 2;
    const y = (e.clientY - rect.top) - height / 2;

    const oldSum = { x: iVec.x + jVec.x, y: iVec.y + jVec.y };
    const newSum = { x: x / unit, y: y / unit };

    const oldLen = vecLength(oldSum);
    const newLen = vecLength(newSum);

    if (oldLen < 1e-3) return;

    const scale = newLen / oldLen;

    const oldAngle = Math.atan2(oldSum.y, oldSum.x);
    const newAngle = Math.atan2(newSum.y, newSum.x);
    const rotation = newAngle - oldAngle;

    const cos = Math.cos(rotation);
    const sin = Math.sin(rotation);

    // Apply rotation then scale to both vectors
    const ix = iVec.x, iy = iVec.y;
    iVec.x = scale * (ix * cos - iy * sin);
    iVec.y = scale * (ix * sin + iy * cos);

    const jx = jVec.x, jy = jVec.y;
    jVec.x = scale * (jx * cos - jy * sin);
    jVec.y = scale * (jx * sin + jy * cos);

    draw();
  });

  handle.addEventListener('pointerup', (e) => {
    handle.releasePointerCapture(e.pointerId);
  });
}

setupHandle(handleI, iVec, 'i');
setupHandle(handleJ, jVec, 'j');
setupSumHandle(handleSum);

const mA = document.getElementById('m-a');
const mB = document.getElementById('m-b');
const mC = document.getElementById('m-c');
const mD = document.getElementById('m-d');

function updateMatrixDisplay() {
  // Matrix columns are the basis vectors
  // | a  c |   | i.x  j.x |
  // | b  d | = | i.y  j.y |
  // Note: negate y because canvas y is flipped
  mA.textContent = iVec.x.toFixed(2);
  mB.textContent = (-iVec.y).toFixed(2);
  mC.textContent = jVec.x.toFixed(2);
  mD.textContent = (-jVec.y).toFixed(2);
}

function drawTransformedGrid() {
  /*
    The inverse of a 2×2 matrix [a c; b d] is:
    T⁻¹ = (1/det) × [  d   -c ]
                    [ -b    a ]

    Where det = ad - bc.
  */
  const [a, b, c, d] = [iVec.x, iVec.y, jVec.x, jVec.y];
  const det = a*d - b*c;
  if (Math.abs(det) < 1e-4) {
    // skip drawing if the basis vectors are parallel
    return;
  }

  /*
    For a screen point (x, y), the pre-transform point is

    [px  = x[d/det    y[-c/det
     py]    -b/det] +    a/det]
    px = x * d/det - y * c/det
    py = x * -b/det + y * a/det

    Apply these to all four corners (pre-transform) to obtain the
    new bounding box.
   */
  const corners = [
    [+halfWidthM, +halfHeightM],
    [-halfWidthM, +halfHeightM],
    [+halfWidthM, -halfHeightM],
    [-halfWidthM, -halfHeightM],
  ]

  const transformed = corners.map(([x, y]) => [
    (x* d - y* c)/det,
    (x* -b + y* a)/det,
  ])

  const hw = Math.max(...transformed.map(([px,_]) => Math.abs(px)));
  const hh = Math.max(...transformed.map(([_,py]) => Math.abs(py)));

  ctx.strokeStyle = '#ddd';
  ctx.strokeStyle = 'rgba(190, 120, 205, 0.8)';
  ctx.lineWidth = 1;

  ctx.save();
  // Apply the matrix transform
  ctx.transform(iVec.x, iVec.y, jVec.x, jVec.y, 0, 0);

  // Same loops as drawGrid, but with a expanded extent
  for (let x = 0; x <= hw; x += spacing) {
    ctx.beginPath();
    ctx.moveTo(x, -hh);
    ctx.lineTo(x, hh);
    ctx.stroke();

    if (x != 0) {
      ctx.beginPath();
      ctx.moveTo(-x, -hh);
      ctx.lineTo(-x, hh);
      ctx.stroke();
    }
  }

  for (let y = 0; y <= hh; y += spacing) {
    ctx.beginPath();
    ctx.moveTo(-hw, y);
    ctx.lineTo(hw, y);
    ctx.stroke();

    if (y != 0) {
      ctx.beginPath();
      ctx.moveTo(-hw, -y);
      ctx.lineTo(hw, -y);
      ctx.stroke();
    }
  }

  ctx.restore();
}

setup();
draw();
</script>

</head>

<body>

<div class="container">
  <canvas></canvas>
  <svg>
    <circle id="handle-i" r="8" fill="#e74c3c" stroke="#fff" stroke-width="2" />
    <circle id="handle-j" r="8" fill="#3498db" stroke="#fff" stroke-width="2" />
    <rect id="handle-sum" width="14" height="14" x="-7" y="-7" fill="#9b59b6" stroke="#fff" stroke-width="2" />
  </svg>
  <div id="matrix-display">
    <div class="matrix-bracket">[</div>
    <div class="matrix-values">
      <div class="matrix-row">
        <span id="m-a">1.00</span>
        <span id="m-c">0.00</span>
      </div>
      <div class="matrix-row">
        <span id="m-b">0.00</span>
        <span id="m-d">1.00</span>
      </div>
    </div>
    <div class="matrix-bracket">]</div>
  </div>
</div>

</body>
</html>
