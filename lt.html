<!DOCTYPE html>
<html lang="en">

<head>

<meta charset="utf-8">
<meta name="viewport" content="width=device-width">

<title>Linear transforms | mnvr.in</title>
<meta name="description" content="An interactive visualization of linear transforms">

<style>
:root {
  color-scheme: light dark;
}
body {
  margin: 0;
}
canvas {
  width: 100%;
  height: 100vh;
}
</style>

<script type="module">
const canvas = document.querySelector("canvas");
const ctx = canvas.getContext("2d");

const spacing = 50;
const margin = -10;

let width, height;
let halfWidth, halfHeight;

function setup() {
  // All drawing will happen in CSS pixels, but we'll scale the canvas pixels
  // to account for the DPR.
  const dpr = Math.floor(Math.min(devicePixelRatio, 2));
  width = canvas.clientWidth;
  height = canvas.clientHeight;

  canvas.width = width * dpr;
  canvas.height = height * dpr;

  ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform
  ctx.scale(dpr, dpr);
  ctx.translate(width / 2, height / 2);

  halfWidth = width / 2 - margin;
  halfHeight = height / 2 - margin;
}

function draw() {
  ctx.clearRect(-halfWidth, -halfHeight, halfWidth, halfHeight);

  drawGrid();
  drawAxes();
  drawBasisVectors();
}

function drawGrid() {
  ctx.strokeStyle = '#ddd';
  ctx.lineWidth = 1;

  // Vertical lines from center outward
  for (let x = 0; x <= halfWidth; x += spacing) {
    ctx.beginPath();
    ctx.moveTo(x, -halfHeight);
    ctx.lineTo(x, halfHeight);
    ctx.stroke();

    if (x != 0) {
      ctx.beginPath();
      ctx.moveTo(-x, -halfHeight);
      ctx.lineTo(-x, halfHeight);
      ctx.stroke();
    }
  }

  for (let y = 0; y <= halfHeight; y += spacing) {
    ctx.beginPath();
    ctx.moveTo(-halfWidth, y);
    ctx.lineTo(halfWidth, y);
    ctx.stroke();

    if (y != 0) {
      ctx.beginPath();
      ctx.moveTo(-halfWidth, -y);
      ctx.lineTo(halfWidth, -y);
      ctx.stroke();
    }
  }
}

function drawAxes() {
  ctx.lineWidth = 2;

  ctx.strokeStyle = '#e74c3c';
  ctx.beginPath();
  ctx.moveTo(-halfWidth, 0);
  ctx.lineTo(halfWidth, 0);
  ctx.stroke();

  ctx.strokeStyle = '#3498db';
  ctx.beginPath();
  ctx.moveTo(0, -halfHeight);
  ctx.lineTo(0, halfHeight);
  ctx.stroke();
}

const unit = spacing; // 1 unit = 50px (same as grid spacing)

const iVec = { x: 1, y: 0 };
const jVec = { x: 0, y: -1 }; // Negative because canvas y is flipped

function drawArrow(from, to, color) {
  const headLength = 10;
  const dx = to.x - from.x;
  const dy = to.y - from.y;
  const angle = Math.atan2(dy, dx);

  ctx.lineCap = 'round';
  ctx.lineJoin = 'round';
  ctx.strokeStyle = color;
  ctx.fillStyle = color;
  ctx.lineWidth = 3;

  // Line
  ctx.beginPath();
  ctx.moveTo(from.x, from.y);
  ctx.lineTo(to.x, to.y);
  ctx.stroke();

  // Arrowhead
  ctx.beginPath();
  ctx.moveTo(to.x, to.y);
  ctx.lineTo(to.x - headLength * Math.cos(angle - Math.PI / 6), to.y - headLength * Math.sin(angle - Math.PI / 6));
  ctx.lineTo(to.x - headLength * Math.cos(angle + Math.PI / 6), to.y - headLength * Math.sin(angle + Math.PI / 6));
  ctx.closePath();
  ctx.fill();
  ctx.stroke();
}

function drawHandle(v, color) {
  const handleRadius = 8;
  const handleOffset = handleRadius + 4;

  const angle = Math.atan2(v.y, v.x)
  const x = v.x + handleOffset * Math.cos(angle);
  const y = v.y + handleOffset * Math.sin(angle);

  ctx.beginPath();
  ctx.arc(x, y, handleRadius, 0, Math.PI * 2);
  ctx.fillStyle = color;
  ctx.fill();
  ctx.strokeStyle = '#fff'
  ctx.lineWidth = 2;
  ctx.stroke();
}

function drawBasisVectors() {
  const origin = { x: 0, y: 0 };

  const iTip = { x: iVec.x * unit, y: iVec.y * unit };
  const jTip = { x: jVec.x * unit, y: jVec.y * unit };

  drawArrow(origin, iTip, '#e74c3c');
  drawArrow(origin, jTip, '#3498db');

  drawHandle(iTip, '#e74c3c');
  drawHandle(jTip, '#3498db');
}

function resize() {
  setup();
  draw();
}

let resizeScheduled = false;

window.addEventListener("resize", () => {
  if (resizeScheduled) return;
  resizeScheduled = true;

  requestAnimationFrame(() => {
    resize();
    resizeScheduled = false;
  });
});

setup();
draw();
</script>

</head>

<body>

<canvas></canvas>

</body>
</html>
